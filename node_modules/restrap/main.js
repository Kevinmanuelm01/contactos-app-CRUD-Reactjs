var rest  = require('restify');
var path  = require('path');
var _     = require('underscore');
var flags = require('node-flags');
var q     = require('q');
var perr  = require('pretty-error');

var restrap = function(){

  var self = this;

  self._config      = {};
  self._libraries   = {};
  self._validations = {};
  self._server      = {};
  self._routes      = [];

  /*
    self._module()
    Private method which accepts a single route instance, validates the request,
    and invokes the module.
    --
    @instance [Object] A single route instance.
  */
  self.module = function(instance){

    var d = q.defer();
    var module = this;

    // Returns an object of params, despite the request type. Optionally merges
    // in an array of injected params (typically from validations).

    module.params = function(merge){
      var params = (instance.req && instance.req.body ? instance.req.body : instance.req.query);
      if(merge){
        _.each(merge, function(param){
          if(typeof param === 'object'){
            params = _.extend(params, param);
          }
        });
      }
      return params;
    };

    // Invoke a new module for a single instance. This loads the module with
    // params, config, libraries, etc.

    q.all(self._validate_map(instance.validate, module.params(), instance)).then(function(pass){
      try {
        instance.module({
          param:   module.params(pass),
          success: d.resolve,
          error:   d.reject,
          library: self.library,
          config:  self.config(),
          instance: {
            req: instance.req
          }
        });
      }
      catch(e){
        d.reject(e);
        self._error('Module Error: ' + instance.id, e);
      }
    },
    d.reject);

    return d.promise;
  };

  /*
    self.route()
    Define a public HTTP route, mapped to a unique module.
    --
    @type   [String] HTTP type of [post, get, put, del].
    @uri    [String] Public end-point (ie. http://127.0.0.1/user).
    @module [String] Relative path to module from the config.module.root.
  */
  self.route = function(type, uri, module){

    var route = this;

    // Restify method to execute during an incoming route request. Passes
    // along a new instance to a mapped module.

    route.request = function(instance){
      return self._server[type](uri, function(req,res){
        instance.req = req;
        instance.res = res;
        new self.module(Object.assign({}, instance)).then(function(success){
          res.send(200, { result: success });
        },
        function(error){
          res.send(400, { error: error });
        });
      });
    };

    // Attach an array of validation string references to the
    // last [chained] route.

    route.validate = function(validations){
      self._routes[self._routes.length - 1].validate = validations;
      return route;
    };

    // Define a new route. Pushes the route to self._routes, along with the
    // coresponding module restify route.

    self._routes.push({
      validate: [],
      id:       module,
      request:  route.request,
      module:   require.apply(null, [self._path(self._config.path.mod + '/' + module)])
    });

    return {
      validate: this.validate
    }
  };

  /*
    self.validate()
    Allows creation of a custom validation module;
    --
    @id     [String]   Unique name of the validation.
    @method [Function] Deferred method for validation.
  */
  self.validate = function(id, method){
    self._validations[id] = function(params, instance){
      var d = q.defer();
      method.apply(null, [{
        param:    params,
        success:  d.resolve,
        error:    d.reject,
        config:   self.config(),
        library:  self.library,
        instance: instance
      }]);
      return d.promise;
    };
  };

  /*
    self.library()
    Import an array of custom libraries to be piped into modules.
    --
    @libraries [Object]  Array of library string references.
    @invoke    [Boolean] Invoke a direct instance of the library or keep a copy.
  */
  self.library = function(libraries){
    if(libraries && typeof libraries === 'object'){
      _.each(libraries, function(library){
        self._libraries[library] = require(self._path(self._config.path.lib + '/' + library));
      });
    }
    else if(libraries && typeof libraries === 'string') {
      return self._libraries[libraries].apply(null, [{ config: self._config, library: self.library }]);
    }
    return self._libraries;
  };

  /*
    self.listen()
    Invokes all defined routes, loading the coresponding modules and preparing
    for incoming HTTP requests.
  */
  self.listen = function(){
    _.each(self._routes, function(route){
      route.request(route);
    });
    self._server.opts('/\.*/', function(req,res,next){
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Headers', 'origin, Origin, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, X-Response-Time, X-PINGOTHER, X-CSRF-Token,Authorization');
      res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, PUT, POST, DELETE, CONNECT, OPTIONS');
      res.setHeader('Access-Control-Request-Headers', 'origin');
      res.setHeader('Access-Control-Expose-Headers', 'X-Api-Version, X-Request-Id, X-Response-Time');
      res.setHeader('Access-Control-Max-Age', '1000');
      return next()
    },
    function(req, res, next){
      res.send(200);
      return next()
    });
    self._server.listen(self._config.server.port);
    console.log('Restrap running at: 127.0.0.1:' + self._config.server.port);
  };

  /*
    self.config()
    Import a local configuration file.
  */
  self.config = function(p){
    if(p){
      self._config = require(self._path(p));
      console.log(self._config.server.cors);

      self._server = rest.createServer();
      self._server.use(rest.queryParser())
      self._server.use(rest.bodyParser({ limit: '500mb' }))
      self._server.use(rest.CORS(self._config.server.cors));
      self._server.use(rest.fullResponse());

      self._server.on('NotFound', self.__error);
      self._server.on('MethodNotAllowed', self.__error);
    }
    return self._config;
  };

  /*
    self.call()
    Direct call to a module.
  */
  self.call = function(flag, module, params, auto){
    var d = q.defer();
    if(flags.get('use') == flag || auto){
      require.apply(null, [self._path(self._config.path.mod + '/' + module)]).apply(null, [{
        param:   params,
        success: d.resolve,
        error:   d.reject,
        library: self.library,
        config:  self.config()
      }]);
    }
    return d.promise;
  };

  /*
    self._validate_map()
    Maps an array of validation string references to their defined
    validation methods.
    --
    @validations [Object] Array of validation string references.
  */
  self._validate_map = function(refs, params, instance){
    return refs.map(function(validation){
      return self._validations[validation](params, instance);
    });
  };

  /*
    self._error()
    Generic CLI error wrapper.
  */
  self._error = function(msg, error){
    var pe = new perr();
    console.log(pe.render(error));
    console.log(msg);
    return true;
  };

  /*
    self.__error()
    Generic server error wrapper.
  */
  self.__error = function(req,res){
    res.send(400, {
      error: 'invalid_resource'
    });
  };

  /*
    self._path()
    Returns relative path to app for dev/prod environments.
  */
  self._path = function(p){
    return (self._env == 'dev' ? './base/' + p : path.join('../../', p));
  };

};

module.exports = function(){
  return new restrap();
};
